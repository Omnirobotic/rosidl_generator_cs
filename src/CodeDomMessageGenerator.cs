using System;
using System.Text;
using System.Reflection;
using System.IO;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Runtime.InteropServices;
using Microsoft.CSharp;

namespace rosidl_generator_cs
{
	public class CodeDomMessageGenerator : IMessageCodeGenerator
	{
		private CodeCompileUnit TargetUnit;
		private CodeTypeDeclaration MessageStruct;
		private CodeTypeDeclaration MessageArrayStruct;
		private CodeTypeDeclaration MessageClass;
		private CodeNamespace MessageNamespace;
		private CompilerResults LastCompilationResults;
		public CodeDomMessageGenerator()
		{
		}
		/// <summary>
		/// Generates the code.
		/// </summary>
		/// <param name="description">Description.</param>
		public void GenerateCode(MessageDescription description)
		{
			//Create a compile unit
			TargetUnit = new CodeCompileUnit();

			//Create the message namespace with srv or msg.
			if (description.IsService)
				MessageNamespace = new CodeNamespace(description.Namespace + ".srv");
			else
				MessageNamespace = new CodeNamespace(description.Namespace + ".msg");
			MessageNamespace.Comments.Add(new CodeCommentStatement("Generated by the rosidl_generator_cs build: " + this.GetType().Assembly.GetName().Version.ToString()));
			MessageNamespace.Comments.Add(new CodeCommentStatement("Generation date: " + System.DateTime.Now.ToString()));
			MessageNamespace.Comments.Add(new CodeCommentStatement(description.InputFile));
			//Add using statements
			MessageNamespace.Imports.Add(new CodeNamespaceImport("System"));
			MessageNamespace.Imports.Add(new CodeNamespaceImport("rclcs"));
			MessageNamespace.Imports.Add(new CodeNamespaceImport("System.Runtime.InteropServices"));
            MessageNamespace.Imports.Add(new CodeNamespaceImport("System.Reflection"));

			//Create the message struct
			MessageStruct = new CodeTypeDeclaration(description.StructName);
			MessageStruct.IsStruct = true;
			MessageStruct.BaseTypes.Add(new CodeTypeReference("IRosMessage"));
			//Add layoutkind attribute
			CodeAttributeDeclaration StructAttribute = new CodeAttributeDeclaration("StructLayout", new CodeAttributeArgument(new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(typeof(System.Runtime.InteropServices.LayoutKind)), "Sequential")));
			MessageStruct.CustomAttributes.Add(StructAttribute);
			MessageStruct.TypeAttributes = TypeAttributes.Public;
			//CodeConstructor StructConstructor = AddStructConstructor(description);
			//Add struct members
			foreach (var item in description.Members)
			{
				AddStructMember(item);
			}

			//Create an array wrapper for the struct
			MessageArrayStruct = new CodeTypeDeclaration(description.StructName + "_array");
			MessageArrayStruct.IsStruct = true;
			//MessageArrayStruct.BaseTypes.Add(new CodeTypeReference("IRosMessage"));

			CodeAttributeDeclaration ArrayStructAttribute = new CodeAttributeDeclaration("StructLayout", new CodeAttributeArgument(new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(typeof(System.Runtime.InteropServices.LayoutKind)), "Sequential")));
			MessageArrayStruct.CustomAttributes.Add(StructAttribute);
			MessageArrayStruct.TypeAttributes = TypeAttributes.Public;
			AddArrayStructMembers(description);

			//Add the interop method which obtains the typesupport
			AddTypeIntrospectionMethod(description);
			//Add the free method needed for memory handling
			AddFreeMethod();
            //Add the Init method to init the members of the struct
            //AddInitMethod();
            //AddImplicitCastFromObject(description);

			//Add the struct to the namespace
			MessageNamespace.Types.Add(MessageStruct);
			MessageNamespace.Types.Add(MessageArrayStruct);
			//Add to namespace
			TargetUnit.Namespaces.Add(MessageNamespace);

			//Create the wrapper class
			MessageClass = new CodeTypeDeclaration(description.Name);
			MessageClass.IsStruct = true;
			MessageClass.BaseTypes.Add("MessageWrapper");

			//Add fields to the message wrapper class
			AddMessageFields(description);
			//Add the constructor
			AddMessageConstructor(description);
			//Adds all the rest of the non dynamic generated methods of the wrapper class
			AddInheritedMethods(description);
			//Add methods (Properties to be exact) for accessing the variables in the structs
			AddSimpleAccessMethods(description);
			AddArrayAccessMethods(description);
			AddNestedAccessMethods(description);
			//Add the wrapper class to the namespace
			MessageNamespace.Types.Add(MessageClass);
		}
		/// <summary>
		/// Gets the generated code.
		/// </summary>
		/// <returns>The generated code as a string.</returns>
		public string GetGeneratedCode()
		{
			CSharpCodeProvider provider = new CSharpCodeProvider();
			StringBuilder codeString = new StringBuilder();
			StringWriter writer = new StringWriter(codeString);
			CodeGeneratorOptions generatorOptions = new CodeGeneratorOptions();
			provider.GenerateCodeFromCompileUnit(TargetUnit, writer, generatorOptions);
			//This adds the unsafe statement which is not supported by codedom ->roselyn supports it
			//We need the unsafe statement for fixed size arrays
			string returnCode = AddUnsafeStatementToStruct(codeString.ToString());
			return returnCode;
		}
		/// <summary>
		/// Adds the unsafe statement to struct code.
		/// </summary>
		/// <returns>The generated code with the unsafe statement.</returns>
		/// <param name="code">Code.</param>
		private string AddUnsafeStatementToStruct(string code)
		{
			int struct_pos = code.IndexOf("struct");
			code = code.Insert(struct_pos, "unsafe ");
			return code;
		}
		/// <summary>
		/// Tests if the generated code compiles.
		/// </summary>
		/// <returns><c>true</c>, if the generated code compiles, <c>false</c> otherwise.</returns>
		/// <param name="rclcsPath">Rclcs path.</param>
		/// <param name="referencesPaths">References paths.</param>
		public bool TestCompileGeneratedCode(string rclcsPath, string[] referencesPaths)
		{
			CSharpCodeProvider provider = new CSharpCodeProvider();
			CompilerParameters compilerOptions = new CompilerParameters();
			compilerOptions.CompilerOptions += " /unsafe";
			//Add the needed references to the compiler parameters
			compilerOptions.ReferencedAssemblies.Add("System");
			compilerOptions.ReferencedAssemblies.Add(rclcsPath);
			compilerOptions.ReferencedAssemblies.AddRange(referencesPaths);
			//And compile it
			LastCompilationResults = provider.CompileAssemblyFromSource(compilerOptions, new string[] { GetGeneratedCode() });
			return false;
		}
		/// <summary>
		/// Gets the last compilation results.
		/// </summary>
		/// <returns>The last compilation results.</returns>
		public CompilerResults GetLastCompilationResults()
		{
			if (LastCompilationResults == null)
				throw new NullReferenceException("You need to start a compilation before");
			return LastCompilationResults;
		}
		/// <summary>
		/// Adds the struct constructor.
		/// </summary>
		/// <returns>The struct constructor.</returns>
		/// <param name="description">Description.</param>
		private CodeConstructor AddStructConstructor(MessageDescription description)
		{
			//Create constructor
			CodeConstructor structConstructor = new CodeConstructor();
			structConstructor.Attributes = MemberAttributes.Public;

			MessageStruct.Members.Add(structConstructor);
			return structConstructor;
		}
		/// <summary>
		/// Adds the array struct members.
		/// </summary>
		/// <param name="description">Description.</param>
		private void AddArrayStructMembers(MessageDescription description)
		{
			//Create new field
			CodeMemberField memberField = new CodeMemberField();

			//Set it to public
			memberField.Attributes = MemberAttributes.Public | MemberAttributes.Final; ;
			//Set the member name
			memberField.Name = "array_ptr";
			//Set the member type 
			memberField.Type = new CodeTypeReference(typeof(IntPtr));
			//Add the field to the struct
			MessageArrayStruct.Members.Add(memberField);

			memberField = new CodeMemberField();

			//Set it to public
			memberField.Attributes = MemberAttributes.Public | MemberAttributes.Final; ;
			//Set the member name
			memberField.Name = "size";
			//Set the member type 
			memberField.Type = new CodeTypeReference(typeof(int));
			//Add the field to the struct
			MessageArrayStruct.Members.Add(memberField);

			memberField = new CodeMemberField();

			//Set it to public
			memberField.Attributes = MemberAttributes.Public | MemberAttributes.Final; ;
			//Set the member name
			memberField.Name = "capacity";
			//Set the member type 
			memberField.Type = new CodeTypeReference(typeof(int));
			//Add the field to the struct
			MessageArrayStruct.Members.Add(memberField);
		}
		/// <summary>
		/// Adds the given struct member to the struct.
		/// </summary>
		/// <param name="member">Member.</param>
		private void AddStructMember(MessageMemberDescription member)
		{
			if (member.IsNested)
			{
				Console.WriteLine("Nested member: " + member.MemberType + " " + member.Name);
				if (member.IsBoundedArray)
					Console.WriteLine("Is bounded array");
				if (member.IsArray)
					Console.WriteLine("Is array");
				//Create new field
				CodeMemberField memberField = new CodeMemberField();
				memberField.Comments.Add(new CodeCommentStatement("Nested member: " + member.RosType));
				//Set it to public
				memberField.Attributes = MemberAttributes.Public | MemberAttributes.Final;
				//Set the member name
				memberField.Name = member.Name;
				//Set the member type 
				if (member.IsArray)
					memberField.Type = new CodeTypeReference(member.MemberType + "_array");
				else
					memberField.Type = new CodeTypeReference(member.MemberType);
				//Add the field to the struct
				MessageStruct.Members.Add(memberField);
			}
			else if (member.IsFixedSizeArray)
			{
				//For a fixed size array we need a customMeber
				CodeSnippetTypeMember customMember = new CodeSnippetTypeMember();
				customMember.Comments.Add(new CodeCommentStatement("Fixed size array member: " + member.RosType));
				//With some custom code
				customMember.Text = "        public fixed " + member.MemberType + " " + member.Name + "[" + member.FixedArraySize.ToString() + "];\n";
				//Add this code to the struct
				MessageStruct.Members.Add(customMember);
			}
			else
			{
				//Create new field
				CodeMemberField memberField = new CodeMemberField();
				memberField.Comments.Add(new CodeCommentStatement("Standard member: " + member.RosType));
				//Set it to public
				memberField.Attributes = MemberAttributes.Public | MemberAttributes.Final;
				//Set the member name
				memberField.Name = member.Name;
				//Set the member type 
				memberField.Type = new CodeTypeReference(member.MemberType);
				//Add the field to the struct
				MessageStruct.Members.Add(memberField);
				//Handling for DefaultValue
				if (member.DefaultInitialisation != "")
				{
					//Parse for ints //TODO parse other types
					/*int val;
					bool success = int.TryParse(member.DefaultInitialisation, out val);
					if (success)
					{
						CodeAssignStatement assignDefaultVal = new CodeAssignStatement(new CodeVariableReferenceExpression(member.Name), new CodePrimitiveExpression(val));
						constructor.Statements.Add(assignDefaultVal);
					}*/

				}
			}


		}
		/// <summary>
		/// Adds the type introspection method.
		/// </summary>
		/// <param name="description">Message description.</param>
		private void AddTypeIntrospectionMethod(MessageDescription description)
		{
			CodeSnippetTypeMember introspectionMethod = new CodeSnippetTypeMember();
			string introspectionMethodName = "";
			if (description.IsService)
			{
				string tempName = description.Name.Replace("_", "");
				tempName = tempName.Replace("Request", "");
				tempName = tempName.Replace("Response", "");
				introspectionMethodName = "rosidl_typesupport_fastrtps_c__get_service_type_support_handle__" + description.Namespace + "__srv__" + tempName;
			}
			else
			{
				introspectionMethodName = " rosidl_typesupport_fastrtps_c__get_message_type_support_handle__" + description.Namespace + "__msg__" + description.Name;
			}
			if (Environment.OSVersion.Platform == PlatformID.Unix) {
				introspectionMethod.Text = "        [DllImport (\"lib" + description.Namespace + "__rosidl_typesupport_c.so\")]\n" +
				"        public static extern IntPtr " + introspectionMethodName + "();";
			} else if (Environment.OSVersion.Platform == PlatformID.Win32NT) {
				introspectionMethod.Text = "        [DllImport (@\"" + description.Namespace + "__rosidl_typesupport_fastrtps_c.dll\")]\n" +
					"        public static extern IntPtr " + introspectionMethodName + "();";
			}
			MessageStruct.Members.Add(introspectionMethod);
		}
		/// <summary>
		/// Adds the free method for memory handling.
		/// </summary>
		private void AddFreeMethod()
		{
			CodeMemberMethod freeMethod = new CodeMemberMethod();
			freeMethod.Attributes = MemberAttributes.Public | MemberAttributes.Final;
			freeMethod.Name = "Free";
			freeMethod.ReturnType = new CodeTypeReference(typeof(void));

			freeMethod.Comments.Add(new CodeCommentStatement("This method calls free on every sub element if the subelement implements the IRosTransportItem interface"));
			CodeSnippetStatement freeIteration = new CodeSnippetStatement();
			freeIteration.Value =
				"           foreach (var item in this.GetType().GetFields()) " +
				"{\n            " +
					"  if (typeof(IRosTransportItem).IsAssignableFrom (item.FieldType))" +
					"{\n               " +
						"    IRosTransportItem ros_transport_item = (IRosTransportItem)item.GetValue(this);" +
					"\n                   ros_transport_item.Free();" +
				"\n              }" +
				"\n           }";
			freeMethod.Statements.Add(freeIteration);
			MessageStruct.Members.Add(freeMethod);
		}

	    /// <summary>
	    /// Adds the implicit cast method to be able to cast objects to the struct class.
	    /// </summary>
        private void AddImplicitCastFromObject(MessageDescription description)
	    {
	        CodeSnippetTypeMember __cstm1 = new CodeSnippetTypeMember("\n\t\t\t\tpublic static "+description.StructName+" FromObject(object obj)");

	        CodeSnippetTypeMember __cstm2 = new CodeSnippetTypeMember("\t\t\t\t{");

	        CodeSnippetTypeMember __cstm3 = new CodeSnippetTypeMember("\t\t\t\t\treturn ("+description.StructName+")obj;");

	        CodeSnippetTypeMember __cstm4 = new CodeSnippetTypeMember("\t\t\t\t}");

	        MessageStruct.Members.Add(__cstm1);

	        MessageStruct.Members.Add(__cstm2);

	        MessageStruct.Members.Add(__cstm3);

	        MessageStruct.Members.Add(__cstm4);
        }

	    /// <summary>
	    /// Adds the Init method to initialize members.
	    /// </summary>
	    private void AddInitMethod()
	    {
	        CodeMemberMethod initMethod = new CodeMemberMethod();
	        initMethod.Attributes = MemberAttributes.Public | MemberAttributes.Final;
	        initMethod.Name = "Init";
	        initMethod.ReturnType = new CodeTypeReference(typeof(void));

	        initMethod.Comments.Add(new CodeCommentStatement("This method initializes every member to a default value"));
	        CodeSnippetStatement initIteration = new CodeSnippetStatement();
	        initIteration.Value =
                "\n           	        Console.WriteLine(\"Init - \" + this.GetType());"+
                "\n                     var type = this.GetType();" +
	            "\n                     var publicItems = type.GetFields();"+
                "\n                     var privateItems = type.GetFields(BindingFlags.Instance | BindingFlags.NonPublic);" +
                "\n                     var totalItems = new FieldInfo[publicItems.Length + privateItems.Length];" +
                "\n                     publicItems.CopyTo(totalItems, 0);" +
                "\n                     privateItems.CopyTo(totalItems, publicItems.Length);" +
                "\n                     foreach (var item in totalItems)" +
                "\n                     {" +
                "\n                         var itemType = item.FieldType;" +
                "\n                         if (typeof(IntPtr) == itemType)" +
                "\n                         {" +
                "\n                             Console.WriteLine(\"Here1\");" +
                "\n                         }" +
                "\n                     " +
                "\n                         var itemPublicItems = itemType.GetFields();" +
	            "\n                         var itemPrivateItems = itemType.GetFields(BindingFlags.Instance | BindingFlags.NonPublic);" +
	            "\n                     " +
	            "\n                         var itemTotalItems = new FieldInfo[itemPublicItems.Length + itemPrivateItems.Length];" +
	            "\n                         itemPublicItems.CopyTo(itemTotalItems, 0);" +
	            "\n                         itemPrivateItems.CopyTo(itemTotalItems, itemPublicItems.Length);" +
	            "\n                     " +
	            "\n                         foreach (var itemSecondLevel in itemTotalItems)" +
	            "\n                         {" +
	            "\n                             var itemTypeSecondLevel = itemSecondLevel.FieldType;" +
	            "\n                             if (typeof(IntPtr) == itemTypeSecondLevel)" +
	            "\n                             {" +
	            "\n                                 Console.WriteLine(\"Here2\");" +
                "\n                                 Console.WriteLine(\"Name :\" +itemSecondLevel.Name);" +
	            "\n                     " +
	            "\n                                 var itemValue = item.GetValue(this);" +
	            "\n                     " +
	            "\n                                 itemSecondLevel.SetValue(itemValue, IntPtr.Zero);" +
	            "\n                     " +
	            "\n                                 object boxed = this;" +
	            "\n                     " +
	            "\n                                 item.SetValue(boxed, itemValue);" +
	            "\n                     " +
	            "\n                                 this = FromObject(boxed);" +
	            "\n                             }" +
	            "\n                         }" +
	            "\n                     }";
            initMethod.Statements.Add(initIteration);
	        MessageStruct.Members.Add(initMethod);
	    }
        /// <summary>
        /// Adds all fields to the message wrapper class. This contains fields needed for the IDisposable Pattern and fields needed for caching nested types
        /// </summary>
        /// <param name="description">Description.</param>
        private void AddMessageFields(MessageDescription description)
		{
			//Boolean field for disposable pattern
			CodeMemberField disposeField = new CodeMemberField();
			disposeField.Attributes = MemberAttributes.Private;
			disposeField.Name = "disposed";
			disposeField.Type = new CodeTypeReference(typeof(bool));


			MessageClass.Members.Add(disposeField);

			//This field contains the data struct
			CodeMemberField dataField = new CodeMemberField();
			dataField.Attributes = MemberAttributes.Private;
			dataField.Name = "__data";
			dataField.Type = new CodeTypeReference(description.StructName);

			MessageClass.Members.Add(dataField);

			//Here we add all needed fields that cache access to the nested types
			foreach (var item in description.Members)
			{
				if (item.IsNested)
				{
					CodeMemberField nestedField = new CodeMemberField();
					nestedField.Attributes = MemberAttributes.Private;
					nestedField.Name = "__" + item.Name;
					//We need to remove the _t because we want the class type and not the struct type
					//TODO Find a nicer solution?
					nestedField.Type = new CodeTypeReference(item.MemberType.Remove(item.MemberType.Length - 2, 2));
					MessageClass.Members.Add(nestedField);
				}
			}



		}
		/// <summary>
		/// Adds the constructors to the message class.
		/// </summary>
		/// <param name="description">Description.</param>
		private void AddMessageConstructor(MessageDescription description)
		{

			CodeConstructor constructor = new CodeConstructor();
		    constructor.ChainedConstructorArgs.Add(new CodeSnippetExpression(""));
            constructor.Name = description.Name;
			constructor.Attributes = MemberAttributes.Public;
			CodeParameterDeclarationExpression constructorParameter = new CodeParameterDeclarationExpression();
			constructorParameter.Name = "_data";
			constructorParameter.Type = new CodeTypeReference(description.StructName);
			constructorParameter.Direction = FieldDirection.Ref;
			constructor.Parameters.Add(constructorParameter);

			CodeAssignStatement constructorStatement = new CodeAssignStatement(new CodeVariableReferenceExpression("__data"), new CodeVariableReferenceExpression("_data"));
			constructor.Statements.Add(constructorStatement);
            MessageClass.Members.Add(constructor);

			/*CodeConstructor emptyConstructor = new CodeConstructor();
			emptyConstructor.Name = description.Name;
			emptyConstructor.Attributes = MemberAttributes.Public;
			foreach (var item in description.Members)
			{
				if (item.IsNested)
				{
					CodeAssignStatement nestedCreateStatement = new CodeAssignStatement(new CodeVariableReferenceExpression("__" + item.Name), new CodeVariableReferenceExpression("new " + item.MemberType.Remove(item.MemberType.Length - 2, 2) + "()"));
					emptyConstructor.Statements.Add(nestedCreateStatement);
				}
			}
			MessageClass.Members.Add(emptyConstructor);*/

		}
		/// <summary>
		/// Adds and implements the inherited (or generally expected methods) from MessageWrapper.
		/// This includes <T> Data, static Type GetMessageType, GetData(out ValueType _data), SetData(ref ValueType _data);
		/// </summary>
		private void AddInheritedMethods(MessageDescription description)
		{
			//This property returns the data struct (To be exact: A copy of it)
			CodeMemberProperty dataProperty = new CodeMemberProperty();
			dataProperty.Name = "Data";
			dataProperty.Type = new CodeTypeReference(description.StructName);
			dataProperty.Attributes = MemberAttributes.Public | MemberAttributes.Final;
			dataProperty.Comments.Add(new CodeCommentStatement("Returns the underlying struct which is wrapped by this class. This struct will be sent in the end"));

			CodeMethodReturnStatement dataPropertyReturnStatement = new CodeMethodReturnStatement(new CodeVariableReferenceExpression("__data"));
			dataProperty.GetStatements.Add(dataPropertyReturnStatement);

			MessageClass.Members.Add(dataProperty);

			//THis method returns the type of the stored message struct
			CodeMemberMethod messageTypeMethod = new CodeMemberMethod();
			messageTypeMethod.Attributes = MemberAttributes.Public | MemberAttributes.Static;
			messageTypeMethod.Name = "GetMessageType";
			messageTypeMethod.ReturnType = new CodeTypeReference(typeof(Type));
			CodeSnippetStatement messageTypeMethodReturnStatement = new CodeSnippetStatement("            return typeof(" + description.StructName + ");"); //Insert spaces for nice formatting -.-
			messageTypeMethod.Statements.Add(messageTypeMethodReturnStatement);

			MessageClass.Members.Add(messageTypeMethod);

			//This method returns the data struct (I think a reference to it)
			CodeMemberMethod getDataMethod = new CodeMemberMethod();
			getDataMethod.Attributes = MemberAttributes.Public | MemberAttributes.Final/*| MemberAttributes.Override*/;
			getDataMethod.Name = "GetData";
			CodeParameterDeclarationExpression getDataMethodParameter = new CodeParameterDeclarationExpression();
			getDataMethodParameter.Name = "_ptr";
			getDataMethodParameter.Type = new CodeTypeReference(typeof(IntPtr));

			getDataMethod.Parameters.Add(getDataMethodParameter);

            getDataMethod.Statements.Add(new CodeSnippetStatement("\t\t\tMarshal.StructureToPtr(this, _ptr, false);"));
			//getDataMethod.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression("_data"), new CodeVariableReferenceExpression("__data")));

			MessageClass.Members.Add(getDataMethod);


			//And the set method
			CodeMemberMethod setDataMethod = new CodeMemberMethod();
			setDataMethod.Attributes = MemberAttributes.Public | MemberAttributes.Final/*| MemberAttributes.Override*/;
			setDataMethod.Name = "SetData";
			CodeParameterDeclarationExpression setDataMethodParameter = new CodeParameterDeclarationExpression();
			setDataMethodParameter.Name = "_ptr";
			setDataMethodParameter.Type = new CodeTypeReference(typeof(IntPtr));

			setDataMethod.Parameters.Add(setDataMethodParameter);
		    
            setDataMethod.Statements.Add(new CodeSnippetStatement("\t\t\tvar structure = ("+description.Name+")Marshal.PtrToStructure(_ptr, typeof("+description.Name+"));"));
            setDataMethod.Statements.Add(new CodeSnippetStatement("\t\t\tthis = structure;"));
            //setDataMethod.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression("__data"), new CodeVariableReferenceExpression("(" + description.StructName + ")_data")));

            MessageClass.Members.Add(setDataMethod);

			//And the dispose method
			CodeMemberMethod disposeMethod = new CodeMemberMethod();
			disposeMethod.Name = "Dispose";
			disposeMethod.Attributes = MemberAttributes.Public | MemberAttributes.Final /*| MemberAttributes.Override | MemberAttributes.Family*/;

			/*CodeParameterDeclarationExpression disposeMethodParameter = new CodeParameterDeclarationExpression();
			disposeMethodParameter.Name = "disposing";
			disposeMethodParameter.Type = new CodeTypeReference(typeof(bool));
			disposeMethod.Parameters.Add(disposeMethodParameter);*/


			CodeConditionStatement disposedCheckStatement = new CodeConditionStatement();
			disposedCheckStatement.Condition = new CodeVariableReferenceExpression("disposed");

			disposedCheckStatement.TrueStatements.Add(new CodeMethodReturnStatement());
			CodeMethodInvokeExpression invokeDisposeStatement = new CodeMethodInvokeExpression(new CodeMethodReferenceExpression(new CodeTypeReferenceExpression("__data"), "Free", new CodeTypeReference[] { }));
			disposedCheckStatement.FalseStatements.Add(invokeDisposeStatement);
			disposeMethod.Statements.Add(disposedCheckStatement);
			disposeMethod.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression("disposed"), new CodePrimitiveExpression(true)));
			MessageClass.Members.Add(disposeMethod);

			//And the SyncDataOut method
			CodeMemberMethod syncDataOutMethod = new CodeMemberMethod();
			syncDataOutMethod.Name = "SyncDataOut";
			syncDataOutMethod.Attributes = MemberAttributes.Public | MemberAttributes.Final/*| MemberAttributes.Override*/;
            syncDataOutMethod.Comments.Add(new CodeCommentStatement("Needed to copy data from the struct in the class instance of the nested member the the real struct"));

			foreach (var item in description.Members)
			{
				if (item.IsNested && !item.IsArray)
				{
					CodeAssignStatement assignDataOutStatement = new CodeAssignStatement();
					assignDataOutStatement.Left = new CodeVariableReferenceExpression("__data." + item.Name);
					assignDataOutStatement.Right = new CodeVariableReferenceExpression("__" + item.Name + ".Data");

					syncDataOutMethod.Statements.Add(assignDataOutStatement);

					CodeMethodInvokeExpression invokeNestedOutSync = new CodeMethodInvokeExpression(new CodeMethodReferenceExpression(new CodeTypeReferenceExpression("__" + item.Name), "SyncDataOut", new CodeTypeReference[] { }));
					syncDataOutMethod.Statements.Add(invokeNestedOutSync);
				}
			}
			MessageClass.Members.Add(syncDataOutMethod);

			//SyncDataIn method
			CodeMemberMethod syncDataInMethod = new CodeMemberMethod();
			syncDataInMethod.Name = "SyncDataIn";
			syncDataInMethod.Attributes = MemberAttributes.Public | MemberAttributes.Final/*| MemberAttributes.Override*/;
            syncDataInMethod.Comments.Add(new CodeCommentStatement("Needed to copy data from the real struct (that one that is stored in __data) to the struct in the class member of the nested type"));

			foreach (var item in description.Members)
			{
				if (item.IsNested && !item.IsArray)
				{
					CodeAssignStatement assignDataInStatement = new CodeAssignStatement();
					assignDataInStatement.Left = new CodeVariableReferenceExpression("__" + item.Name);
					//TODO use invoke expression
					assignDataInStatement.Right = new CodeVariableReferenceExpression("new " + item.MemberType.Remove(item.MemberType.Length - 2, 2) + "(ref __data." + item.Name + ")");

					syncDataInMethod.Statements.Add(assignDataInStatement);

					CodeMethodInvokeExpression invokeNestedInSync = new CodeMethodInvokeExpression(new CodeMethodReferenceExpression(new CodeTypeReferenceExpression("__" + item.Name), "SyncDataIn", new CodeTypeReference[] { }));
					syncDataInMethod.Statements.Add(invokeNestedInSync);
				}
			}
			MessageClass.Members.Add(syncDataInMethod);

            /*var initMethod = new CodeMemberMethod();
		    initMethod.Name = "Init";
            initMethod.Attributes = MemberAttributes.Public | MemberAttributes.Override;
		    initMethod.Comments.Add(
		        new CodeCommentStatement("This method initializes the members to a default value."));
		    var statement = new CodeSnippetStatement
		    {
		        Value = "                   Console.WriteLine(\"Initializing "+description.Name+"\");\n" +
                        "                   var items = this.GetType().GetMembers(BindingFlags.NonPublic | BindingFlags.Instance);\n" +
                        "                   Console.WriteLine(\"Number of items : \" + items.Length);" +
                        "                   foreach(var item in items)\n" +
                        "                   {\n" +
                        "                       Console.WriteLine(item.Name+\" : \"+item.MemberType);\n" +
                        "                           if(item is PropertyInfo)\n" +
                        "                           {\n" +
                        "                               PropertyInfo propertyInfo = (PropertyInfo)item;\n" +
                        "                               var instanceOfItem = propertyInfo.GetValue(this);\n" +
                        "                               if(instanceOfItem is " + description.StructName + ")\n" +
                        "                               {\n" +
		                "                                   var castedInstance = (" + description.StructName + ") instanceOfItem;\n" +
		                "                                  Console.WriteLine(\"Calling init (property)!\");\n" +
		                "                                  castedInstance.Init();\n" +
		                "                               }\n" +
                        "                           }\n" +
		                "                           else if(item is FieldInfo)\n" +
		                "                           {\n" +
                        "                               FieldInfo fieldInfo = (FieldInfo)item;\n" +
		                "                               var instanceOfItem = fieldInfo.GetValue(this);\n" +
                        "                               if(instanceOfItem is " + description.StructName + ")\n" +
		                "                               {\n" +
		                "                                   var castedInstance = ("+description.StructName+") instanceOfItem;\n" +
                        "                                  Console.WriteLine(\"Calling init (field)!\");\n" +
                        "                                  castedInstance.Init();\n" +
		                "                               }\n" +
		                "                           }\n" +
                        "                           else\n" +
                        "                           {\n" +
                        "                               Console.WriteLine(\"Not a property or a field.\");\n" +
                        "                           }\n" +
                        "                   }"
		    };
		    initMethod.Statements.Add(statement);
            MessageClass.Members.Add(initMethod);*/

            var printMethod = new CodeMemberMethod();
		    printMethod.Name = "PrintValue";
		    printMethod.Attributes = MemberAttributes.Final | MemberAttributes.Public;
		    foreach (var item in description.Members)
		    {
		        var itemName = item.Name;
		        if (itemName.EndsWith("\r"))
		        {
		            itemName = itemName.Substring(0, itemName.Length - 1);
		        }
                var printStatement1 = new CodeSnippetStatement("\t\t\tConsole.WriteLine(\"Member : "+ itemName + "\");");
                var printStatement2 = new CodeSnippetStatement("\t\t\tConsole.WriteLine(\"Value : \"+"+ itemName + ".ToString());");
		        printMethod.Statements.Add(printStatement1);
		        printMethod.Statements.Add(printStatement2);
		    }
		    MessageClass.Members.Add(printMethod);
        }
		/// <summary>
		/// Adds methods to the wrapper class for accessing simple fields like integers
		/// </summary>
		/// <param name="description">Description.</param>
		private void AddSimpleAccessMethods(MessageDescription description)
		{
			foreach (var item in description.Members)
			{
				//Check for a simple type
				if (!item.IsArray && !item.IsNested && !item.IsFixedSizeArray)
				{
					CodeMemberProperty simpleAccessProperty = new CodeMemberProperty();
					simpleAccessProperty.Name = item.Name;
					simpleAccessProperty.Attributes = MemberAttributes.Public | MemberAttributes.Final;
					simpleAccessProperty.Type = new CodeTypeReference(item.MemberType);
					//Some extra treatment for strings, they need to be handled like arrays but are still simple types
					//TODO Let strings behave like an array ?
					if (item.MemberType.Contains("String"))
					{
						simpleAccessProperty.Type = new CodeTypeReference(typeof(string));
						CodeMethodReturnStatement simpleAccessPropertyReturnStatement = new CodeMethodReturnStatement(new CodeVariableReferenceExpression("__data." + item.Name + ".ToString()"));
						simpleAccessProperty.GetStatements.Add(simpleAccessPropertyReturnStatement);


						CodeMethodInvokeExpression freeOldDataStatement = new CodeMethodInvokeExpression(new CodeMethodReferenceExpression(new CodeTypeReferenceExpression("__data." + item.Name), "Free", new CodeTypeReference[] { }));
						simpleAccessProperty.SetStatements.Add(freeOldDataStatement);

						CodeAssignStatement createNewDataStatement = new CodeAssignStatement(new CodeVariableReferenceExpression("__data." + item.Name), new CodeVariableReferenceExpression("new " + item.MemberType + "(value)"));
						simpleAccessProperty.SetStatements.Add(createNewDataStatement);

					}
					else
					{
						CodeMethodReturnStatement simpleAccessPropertyReturnStatement = new CodeMethodReturnStatement(new CodeVariableReferenceExpression("__data." + item.Name));
						simpleAccessProperty.GetStatements.Add(simpleAccessPropertyReturnStatement);

						CodeAssignStatement simpleAccessPropertySetStatement = new CodeAssignStatement(new CodeVariableReferenceExpression("__data." + item.Name), new CodeVariableReferenceExpression("value"));
						simpleAccessProperty.SetStatements.Add(simpleAccessPropertySetStatement);
					}
					MessageClass.Members.Add(simpleAccessProperty);
				}
			}
		}
		/// <summary>
		/// Adds methods for accessing arrays
		/// </summary>
		/// <param name="description">Description.</param>
		private void AddArrayAccessMethods(MessageDescription description)
		{
			foreach (var item in description.Members)
			{
				if (item.IsArray && !item.IsFixedSizeArray && !item.IsNested)
				{
					CodeMemberProperty arrayAccessProperty = new CodeMemberProperty();
					arrayAccessProperty.Name = item.Name;
					arrayAccessProperty.Attributes = MemberAttributes.Public | MemberAttributes.Final;
					//Some extra stuff for string arrays
					string dataAccessMethodName = "Array";
					if (item.MemberType.ToLower().Contains("string"))
					{

						arrayAccessProperty.Type = new CodeTypeReference(typeof(string[]));
					}
					else if (item.MemberType.ToLower().Contains("bool"))
					{
						//Extra handling for bool
						arrayAccessProperty.Type = new CodeTypeReference(typeof(bool[]));
					}
					else
					{

						arrayAccessProperty.Type = new CodeTypeReference(item.ArrayReturnType + "[]");
					}
					CodeMethodReturnStatement arrayAccessPropertyReturnStatement = new CodeMethodReturnStatement(new CodeVariableReferenceExpression("__data." + item.Name + "." + dataAccessMethodName));
					arrayAccessProperty.GetStatements.Add(arrayAccessPropertyReturnStatement);

					CodeMethodInvokeExpression freeOldDataStatement = new CodeMethodInvokeExpression(new CodeMethodReferenceExpression(new CodeTypeReferenceExpression("__data." + item.Name), "Free", new CodeTypeReference[] { }));
					arrayAccessProperty.SetStatements.Add(freeOldDataStatement);

					CodeAssignStatement createNewDataStatement = new CodeAssignStatement(new CodeVariableReferenceExpression("__data." + item.Name), new CodeVariableReferenceExpression("new " + item.MemberType + "(value)"));
					arrayAccessProperty.SetStatements.Add(createNewDataStatement);
					MessageClass.Members.Add(arrayAccessProperty);
				}
				else if (item.IsFixedSizeArray && !item.IsNested)
				{
					CodeMemberProperty fixedArrayAccessProperty = new CodeMemberProperty();
					fixedArrayAccessProperty.Name = item.Name;
					fixedArrayAccessProperty.Attributes = MemberAttributes.Public | MemberAttributes.Final;

					//TODO Probably some stuff for strings is needed here
					string fixedArrayType = item.MemberType + "[]";
					fixedArrayAccessProperty.Type = new CodeTypeReference(fixedArrayType);

					CodeSnippetStatement fixedArrayGetMethod = new CodeSnippetStatement();
					fixedArrayGetMethod.Value =
											"                unsafe{\n" +
											"                    " + fixedArrayType + " temp = new " + item.MemberType + "[" + item.FixedArraySize + "];\n" +
											"                    fixed(" + item.MemberType + "* buffer = __data." + item.Name + "){\n" +
											"                        for(int i = 0; i < " + item.FixedArraySize + "; i++){\n" +
											"                            temp[i] = buffer[i];\n" +
											"                        }\n" +
											"                    }\n" +
											"                    return temp;\n" +
											"                }";

					fixedArrayAccessProperty.GetStatements.Add(fixedArrayGetMethod);

					CodeSnippetStatement fixedArraySetMethod = new CodeSnippetStatement();
					fixedArraySetMethod.Value =
											"                unsafe{\n" +
											"                    " + fixedArrayType + "temp = value;\n" +
											"                    fixed(" + item.MemberType + "* buffer = __data." + item.Name + "){\n" +
											"                        for(int i = 0; i < temp.Length; i++){\n" +
											"                            buffer[i] = temp[i];\n" +
											"                        }\n" +
											"                    }\n" +
											"                }";

					fixedArrayAccessProperty.SetStatements.Add(fixedArraySetMethod);
					MessageClass.Members.Add(fixedArrayAccessProperty);


				}
				else if (item.IsNested && item.IsArray)
				{
					CodeMemberProperty arrayAccessProperty = new CodeMemberProperty();
					arrayAccessProperty.Name = item.Name;
					arrayAccessProperty.Attributes = MemberAttributes.Public | MemberAttributes.Final;
				}
			}

		}
		/// <summary>
		/// Adds methods for accessing nested types
		/// </summary>
		/// <param name="description">Description.</param>
		private void AddNestedAccessMethods(MessageDescription description)
		{
			foreach (var item in description.Members)
			{
				if (item.IsNested)
				{
					CodeMemberProperty nestedTypeAccessProperty = new CodeMemberProperty();
					nestedTypeAccessProperty.Name = item.Name;
					nestedTypeAccessProperty.Attributes = MemberAttributes.Public | MemberAttributes.Final;
					nestedTypeAccessProperty.Type = new CodeTypeReference(item.MemberType.Remove(item.MemberType.Length - 2, 2));

					CodeMethodReturnStatement nestedTypeReturnStatement = new CodeMethodReturnStatement(new CodeVariableReferenceExpression("__" + item.Name));
					nestedTypeAccessProperty.GetStatements.Add(nestedTypeReturnStatement);

					MessageClass.Members.Add(nestedTypeAccessProperty);

				}
			}
		}
	}
}

